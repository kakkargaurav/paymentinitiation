name: Build, Publish and Deploy Australian Payment API

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

env:
  REGISTRY: repo.gauravkakkar.au
  IMAGE_NAME: australian-payment-api
  CONTAINER_NAME: australian-payment-api
  PORT: 3232

jobs:
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.version.outputs.new-tag }}
      image-full: ${{ steps.version.outputs.full-image }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Generate version tag
      id: version
      run: |
        # Get current version from package.json
        CURRENT_VERSION=$(grep '"version"' package.json | cut -d'"' -f4)
        echo "Current version: $CURRENT_VERSION"
        
        # Extract major and minor version (assuming format x.y.z)
        MAJOR=$(echo $CURRENT_VERSION | cut -d'.' -f1)
        MINOR=$(echo $CURRENT_VERSION | cut -d'.' -f2)
        
        # Increment minor version by 1 (1.1 -> 1.11, following the pattern)
        NEW_MINOR=$((MINOR + 1))
        NEW_TAG="${MAJOR}.${MINOR}${NEW_MINOR}"
        
        # If current is 1.1, next should be 1.11 as requested
        if [ "$CURRENT_VERSION" = "1.1.0" ] || [ "$CURRENT_VERSION" = "1.1" ]; then
          NEW_TAG="1.11"
        fi
        
        FULL_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${NEW_TAG}"
        
        echo "New tag: $NEW_TAG"
        echo "Full image: $FULL_IMAGE"
        echo "new-tag=$NEW_TAG" >> $GITHUB_OUTPUT
        echo "full-image=$FULL_IMAGE" >> $GITHUB_OUTPUT
    
    - name: Build Docker image
      run: |
        docker build -t ${{ steps.version.outputs.full-image }} .
        docker tag ${{ steps.version.outputs.full-image }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
    # - name: Test Docker image
    #   run: |
    #     # Start container in background
    #     docker run -d --name test-container -p 3233:3232 ${{ steps.version.outputs.full-image }}
        
    #     # Wait for container to start
    #     sleep 10
        
    #     # Basic health check
    #     curl -f http://localhost:3233/health || exit 1
        
    #     # Clean up
    #     docker stop test-container
    #     docker rm test-container
        
    - name: Save Docker image
      run: |
        docker save ${{ steps.version.outputs.full-image }} > /tmp/image.tar
        
    - name: Upload Docker image artifact
      uses: actions/upload-artifact@v4
      with:
        name: docker-image
        path: /tmp/image.tar
        retention-days: 1

  publish:
    name: Publish to Registry
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
    - name: Download Docker image artifact
      uses: actions/download-artifact@v4
      with:
        name: docker-image
        path: /tmp
        
    - name: Load Docker image
      run: |
        docker load < /tmp/image.tar
        
    - name: Login to Container Registry
      run: |
        echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY }} -u "${{ secrets.REGISTRY_USERNAME }}" --password-stdin
        
    - name: Push Docker image
      run: |
        docker push ${{ needs.build.outputs.image-full }}
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
    # - name: Logout from registry
    #   run: |
    #     docker logout ${{ env.REGISTRY }}

  # deploy:
  #   name: Deploy to Production
  #   runs-on: ubuntu-latest
  #   needs: [build, publish]
  #   if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
  #   environment: 
  #     name: production
  #     url: http://your-production-server:3232
    
    steps:
    - name: Deploy to Production Server
      run: |
        echo "Deploying ${{ needs.build.outputs.image-full }} to production..."
        
        # Note: This step assumes you have SSH access to your production server
        # You'll need to set up SSH keys and server details in GitHub secrets
        
        # For demonstration, showing the commands that would be executed on the server
        echo "Commands that will be executed on production server:"
        echo "1. Login to registry:"
        echo "   docker login ${{ env.REGISTRY }} -u ${{ secrets.REGISTRY_USERNAME }} -p ${{ secrets.REGISTRY_PASSWORD }}"
        echo ""
        echo "2. Stop and remove existing container:"
        echo "   docker stop ${{ env.CONTAINER_NAME }} || true"
        echo "   docker rm ${{ env.CONTAINER_NAME }} || true"
        echo ""
        echo "3. Pull new image:"
        echo "   docker pull ${{ needs.build.outputs.image-full }}"
        echo ""
        echo "4. Run new container:"
        echo "   docker run -d --name ${{ env.CONTAINER_NAME }}-${{ needs.build.outputs.image-tag }} \\"
        echo "     -p ${{ env.PORT }}:${{ env.PORT }} \\"
        echo "     --restart unless-stopped \\"
        echo "     ${{ needs.build.outputs.image-full }}"
        echo ""
        echo "5. Verify deployment:"
        echo "   curl -f http://localhost:${{ env.PORT }}/health"
        echo ""
        echo "6. Clean up old images:"
        echo "   docker system prune -f"

    # Uncomment and modify the following step when you have SSH access configured
    # - name: Execute deployment on production server
    #   uses: appleboy/ssh-action@v1.0.0
    #   with:
    #     host: ${{ secrets.PRODUCTION_HOST }}
    #     username: ${{ secrets.PRODUCTION_USER }}
    #     key: ${{ secrets.PRODUCTION_SSH_KEY }}
    #     port: ${{ secrets.PRODUCTION_PORT }}
    #     script: |
    #       # Login to registry
    #       echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY }} -u "${{ secrets.REGISTRY_USERNAME }}" --password-stdin
    #       
    #       # Stop and remove existing container
    #       docker stop ${{ env.CONTAINER_NAME }} || true
    #       docker rm ${{ env.CONTAINER_NAME }} || true
    #       
    #       # Pull new image
    #       docker pull ${{ needs.build.outputs.image-full }}
    #       
    #       # Run new container with tag in name
    #       docker run -d --name ${{ env.CONTAINER_NAME }}-${{ needs.build.outputs.image-tag }} \
    #         -p ${{ env.PORT }}:${{ env.PORT }} \
    #         --restart unless-stopped \
    #         ${{ needs.build.outputs.image-full }}
    #       
    #       # Verify deployment
    #       sleep 10
    #       curl -f http://localhost:${{ env.PORT }}/health
    #       
    #       # Clean up old images
    #       docker system prune -f
    #       
    #       # Logout from registry
    #       docker logout ${{ env.REGISTRY }}

  cleanup:
    name: Cleanup Artifacts
    runs-on: ubuntu-latest
    needs: [build, publish, deploy]
    if: always()
    
    steps:
    - name: Delete artifacts
      uses: geekyeggo/delete-artifact@v4
      with:
        name: docker-image
        failOnError: false